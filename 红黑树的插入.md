# 红黑树的插入

## 1、旋转

我觉得要学习红黑树的话，本身就已经对旋转这个操作有理解，因为我觉得应该具备二叉树调整的基础，不然也无法理解我开头的说的为什么有红黑树。这里简单带过一下
![ROTATION](./pics/ROTATION.PNG "ROTATION")

伪代码实现左旋转
```
LeftRotation(X)
    Y = X.right
    X.right = Y.left        //将y的左子树转移到x的右子树上
    if (Y.left != NIL)     //避免设置哨兵的其他属性
        Y.left.p = X         
    Y.p = X.p               //将x的父母链接到y上
    if (X.p == NIL)        
        Root = Y
    else if (X == X.p.left)
        X.p.left = Y
    else 
        X.p.right = Y
    Y.left = X          //将x放到y的左子树上
    X.p = Y
```
右旋转的代码大同小异，不过是将方向调转

## 2、插入
### 2.1 前言
我们这样想，当你准备往一个已经平衡了的红黑树上插入一个新的结点的时候，你会怎么让新节点染上红色还是黑色呢？考虑到要维系红黑树的平衡定义的第五点有**黑高相同**（详情请见上一章），答案应该是显而易见的红色。

但是当插入结点的颜色为红色的时候就万无一失了吗？明显也是不可能的。想象在红黑树上找到新插入的结点的位置，插入红色的新结点的父结点也为红色的，是否就违背红黑树的平衡定义的第四点**红色节点的父节点和子节点只能是黑色的，即不能有相邻的两个红色节点**。现在，我们就开始真正面对红黑树的复杂。

### 2.2 伪代码
在这里我们先给出对应的伪代码实现过程，然后再从实际的例子看如何操作。
```
Insert(Z)
    Y = NIL
    X = Root
    while (X != NIL)
        Y = X
        if (Z.key < X.key)
            X = X.left
        else
            X = X.right
    Z.p = Y                //找到新节点的插入位置
    if (Y == NIL)
        Root = Z
    else if (Z.key < Y.key)
        Y.left = Z
    else
        Y.right = Z
    Z.left = NIL
    Z.right = NIL
    Z.color = RED
    InsertFixup(Z)          
```
在插入后，调用InsertFixup()函数，下面是伪代码实现
```
InsertFixup(Z) 
    while (Z.p.color == RED)
        if (Z.p == Z.p.p.left)
            Y = Z.p.p.right

            if (Y.color == RED)        //case 1
                Z.p.color = BLACK
                Y.color = BLACK
                Z.p.p.color = RED
                Z = Z.p.p             //case 1

            else 

                if (Z == Z.p.right)     //case 2
                    Z = Z.p
                    LeftRotation(Z)     //case 2

                Z.p.color = BLACK       //case 3
                Z.p.p.color = RED
                RightRotation(Z.p.p)    //case 3
        
        else 
            ... //跟上面相反即Z的父节点为Z的祖父节点的右节点的时候
    Root.color = BLACK
```
### 2.3 实例解析
因为新插入的节点**Z**颜色为红色，所以我们明确在插入后被破坏的红黑树平衡规则只可能会是：1、根节点的颜色必须为黑；2、红色节点的孩子节点一定是黑色的，因此可得红色节点的父母节点也一定是黑色的。第一点的修复调整应该很易想得到，就是将根节点染为黑色即可。那么第二点呢？


如果当其**父节点为红色**的时候（易得祖父节点**G**为黑色），我们就需要在插入节点后进行调整（InsertFixup函数主要做的工作，循函数内主循环也会停止在基准节点**Z**（红色）的父节点**P**为黑色的时候）。

我们再明确一个概念，一个节点的**黑色深度**为：从根节点到该节点（包括该节点本身及根节点）的简单路径上黑色节点的数目。

在上述的大前提下，我们开始讨论，根据其父节点的兄弟节点**Y**的颜色分情况：
#### 1、父节点的兄弟节点也为红色（CASE1）
![InsertCASE1.1](./pics/InsertCASE1.1.PNG "InsertCASE1.1")
只需将祖父染红，父节点**P**以及父节点的兄弟节点**Y**染黑。
![InsertCASE1.2](./pics/InsertCASE1.2.PNG "InsertCASE1.2")
此时**Z**节点的父亲已为黑色，并且很容易看出来所有子树α、β、γ、δ和 ε上的节点以及**Z**、**P**、**Y**、**G**的黑色深度都不会改变。但我们注意到，因为**G**被染成了红色，且它本来的颜色为黑色，当**G**节点的父节点的颜色万一也是红色的话，或者**G**节点为根节点的时候，就会继续违反了红黑树的原则。


所以我们将**G**节点设定为新的的**Z**基准节点去重新进入这个循环，直到基准节点的父节点的颜色为黑色。（根节点的父节点为哨兵节点，哨兵节点的颜色为黑色）
#### 2、父节点的兄弟节点为黑色
那么我们此时需要看节点**Z**是否跟父节点为同一边。同一边的定义为：如果父节点为祖父节点的左孩子，**Z**为父节点的左孩子。非同一边的定义则相反。
##### 2.1新插入节点跟父节点在同一边时（CASE3）
![InsertCASE2.2](./pics/InsertCASE2.2.PNG "InsertCASE2.2")
我们将祖父节点和父节点的颜色互换，意味着将父节点染黑，祖父节点染红，然后以父节点为基准进行右转，此时我们得到。
![InsertFinish](./pics/InsertFinish.PNG "InsertFinish")
很容易从图上看到，从根节点到α、β等子树的上的节的黑色深度没有变化。（尽管该例子的根节点发生了改变）
##### 2.2新插入节点跟父节点不在同一边时（CASE2）
![InsertCASE2.1](./pics/InsertCASE2.1.PNG "InsertCASE2.1")
我们将**Z**节点指向原来的父节点，然后以父节点为基准进行左旋，这个时候我们可以看到，这就是上述情形2.1。
![InsertCASE2.2](./pics/InsertCASE2.2.PNG "InsertCASE2.2")
而且你可以从图上看到，从根节点到α、β等子树的上的节的黑色深度没有变化，所以按着上述情形2.1进行操作即可。
### 2.4 总结
总的来说，插入新的红色节点的时候，如果新节点的父节点为红色，则以该新的节点为基准节点进入调整循环，直至基准节点的父节点为黑色。此时根据父节点的兄弟节点，即叔节点，的颜色进行分情况讨论。如果叔节点的颜色为红色，即代码中的case1，进行染色操作，然后将基准节点往上调整继续循环。如果叔节点的颜色为黑色，是无法通过单纯的染色操作来使红黑树继续平衡（自己可以试一下），我们需要根据**Z**节点和**P**节点是否在同一边的，不是在同一边的话需要转到先转到同一边，即代码中的case2，是同一边的再进行染色旋转调整，即代码中的case3，最后得到一颗平衡的红黑树。